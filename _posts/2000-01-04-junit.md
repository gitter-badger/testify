---
title: "JUnit"
bg:  fnavy
color: white
fa-icon: plug
---

## Unit Test
Given a `Greeter` class with a single `Greeting` collaborator:

{% highlight java linenos=table %}
public class Greeter {

    private final Greeting greeting;

    public Greeter(Greeting greeting) {
        this.greeting = greeting;
    }

    public String greet() {
        return greeting.phrase();
    }

    public Greeting getGreeting() {
        return greeting;
    }

}
{% endhighlight %}

{% highlight java linenos=table %}
public interface Greeting {

    String phrase();

}
{% endhighlight %}

The unit test for the `Greeter` class would look:

{% highlight java linenos=table %}
package com.fitbur.testify.examples.junit.unittest;

import com.fitbur.testify.Cut;
import com.fitbur.testify.Fake;
import com.fitbur.testify.junit.UnitTestRunner;
import static org.assertj.core.api.Assertions.assertThat;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import static org.mockito.BDDMockito.given;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;

@RunWith(UnitTestRunner.class)
public class GreeterTest {

    @Cut
    Greeter cut;

    @Fake
    Greeting greeting;

    @Before
    public void verifyInjection() {
        assertThat(cut).isNotNull();
        assertThat(greeting).isNotNull();
        assertThat(cut.getGreeting()).isSameAs(greeting);
    }

    @Test
    public void callToGreetShouldReturnHello() {
        //Arrange
        String phrase = "Hello";
        given(greeting.phrase()).willReturn(phrase);

        //Act
        String result = cut.greet();

        //Assert
        assertThat(result).isEqualTo(phrase);
        verify(greeting).phrase();
        verifyNoMoreInteractions(greeting);
    }

}
{% endhighlight %}

UnitTestRunner? @Cut? @Fake? WTFIT?

The first thing you will notice in the above test class is that the test is using
Testify's JUnit `UnitTestRunner`. `UnitTestRunner` helps configure, verify, wire,
and run the test class. 

The next thing you will notice are two annotations, `@Cut` and `@Fake`. The `@Cut`
annotation denotes the class under test and `@Fake` denotes the desire to fake
the Greeter class's collaborator. These annotations inform the framework what
we are testing. Behind the scene the framework inspects the test class fields
and the constructor of the class under test. It then creates a) a fake instance
of `Greeting`, b) an instance of `Greeter` with the fake `Greeting` instance as its
collaborator and c) finally sets test class' "cut" and "greeting" fields.

One other key feature of Testify of note is the fact that for each test case a
new `Greeter` and fake Greeting instances are created. This means your tests run
in isolation and you don't have to worry about managing state between test runs.
 It's all done for you so you can focus on writing your test cases not
boilerplate code and managing test states.

---

## Spring Integration Test
Given a `Greeter` service with a single `Greeting` collaborator:

{% highlight java linenos=table %}
@Named
public class Greeter {

    private final Greeting greeting;

    @Inject
    Greeter(Greeting greeting) {
        this.greeting = greeting;
    }

    public String greet() {
        return greeting.phrase();
    }

    public Greeting getGreeting() {
        return greeting;
    }

}
{% endhighlight %}

{% highlight java linenos=table %}
public interface Greeting {

    String phrase();

}
{% endhighlight %}

The following Spring Java Config and implementation of the `Greeting` contract:

{% highlight java linenos=table %}
@ComponentScan
@Configuration
@SuppressWarnings("ClassMayBeInterface")
public class GreetingConfig {

}
{% endhighlight %}

{% highlight java linenos=table %}
@Named
public class Hello implements Greeting {

    @Override
    public String phrase() {
        return "Hello";
    }

}
{% endhighlight %}

The Spring integration test for the `Greeter` service would look:

{% highlight java linenos=table %}
package com.fitbur.testify.examples.junit.Spring.integrationtest;

import com.fitbur.testify.Cut;
import com.fitbur.testify.Module;
import com.fitbur.testify.Real;
import com.fitbur.testify.examples.junit.Spring.integrationtest.greeting.Hello;
import com.fitbur.testify.integration.SpringIntegrationTestRunner;
import static org.assertj.core.api.Assertions.assertThat;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

@Module(GreetingConfig.class)
@RunWith(SpringIntegrationTestRunner.class)
public class GreeterRealTest {

    @Cut
    Greeter cut;

    @Real
    Hello greeting;

    @Before
    public void verifyInjection() {
        assertThat(cut).isNotNull();
        assertThat(greeting).isNotNull();
        assertThat(cut.getGreeting()).isSameAs(greeting);
    }

    @Test
    public void callToGreetShouldReturnHello() {
        //Arrange
        String phrase = "Hello";

        //Act
        String result = cut.greet();

        //Assert
        assertThat(result).isEqualTo(phrase);
    }
}
{% endhighlight %}

SpringIntegrationTestRunner? @Module? @Cut? @Real? Whaaah?

`SpringIntegrationTestRunner` is similar `UnitTestRunner` in that it helps with the
configuration, verification, wiring and running the test class.

Since this is an integration test we are trying to verify proper wiring and
integration between components and their collaborators. Usually this involves
loading a module that defines the service and collaborators we are trying to
test and working with real objects rather than fake ones.

In our `GreeterRealTest` example the Greeter service and its collaborators
are discovered through `GreetingConfig` Spring configuration class. We let
the framework know this by annotating the test class with
`@Module(GreetingConfig.class)`. Behind the scenes the framework will create a new
Spring `ApplicationContext` and registers and loads the `GreetingConfig
configuration class.

We have already seen `@Cut` annotation in action. In the context of a Spring
integration test it serves a similar purpose, to let the framework know what we
are testing. In this example it happens to be a `Greeter` service and its
collaborator.

As mentioned earlier we typically want to work with real instance of 
collaborators in integration test and so we annotate the greeting field with
`@Real` to let the framework know that we want the real instance of the Hello
greeting collaborator managed by Spring. Of course there are times when you
don't want to use the real instance of a class under test's collaborators and in
those instances you can use `@Fake` to work with fake instance of the `Hello` class.

What if you want to use a the real instance but want to stub or verify certain
methods of the collaborator? Well, you can do that too. You just need to
annotate the greeting field with `@Real(true)` to create a fake instance that
delegates to the real instance.

At this point you might be curious as to what's going on behind the scenes.
Well, behind the sense the framework inspects the test class fields
and the constructor of the class under test. It then a) creates a Spring
application context and loads the `GreetingConfig` module, b) gets all the
collaborators of the `Greeter` service from the application context,
c) creates a new instance of the `Greeter` services with real or fake instances of
its collaborators, d) adds the newly created `Greeter` instance to the application
context as a primary bean, and e) finally sets test class's "cut" and "greeting"
fields.

As with unit tests you don't have to worry about managing test state. Every test
case runs in complete isolation. The framework takes care of managing the Spring
application context so you can focus on writing effective Spring integration
tests.