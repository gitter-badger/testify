---
title: "Test Needs"
bg:  forange
color: white
fa-icon: plug
---

---

## Spring Integration Test with a In-Memory HSQLDB Need

---

### Configure Dependencies
For Spring Integration with HSQL need add the following dependencies:

{% highlight text linenos=table %}
<dependency>
    <groupId>com.fitbur.testify.junit</groupId>
    <artifactId>spring-integration-test</artifactId>
    <version>latest</version>
    <scope>test</scope>
</dependency>

<dependency>
    <groupId>com.fitbur.testify.need</groupId>
    <artifactId>need-hsql</artifactId>
    <version>latest</version>
    <scope>test</scope>
</dependency>

<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>4.2.3.RELEASE</version>
</dependency>

<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>4.2.3.RELEASE</version>
</dependency>

<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <version>4.12</version>
    <scope>test</scope>
</dependency>

<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <version>2.0.31-beta</version>
    <scope>test</scope>
</dependency>
{% endhighlight %}

### Example Integration Test Need
Given a `Greeter` service with a single `Greeting` collaborator:

{% highlight java linenos=table %}
@Named
public class Greeter {

    private final SessionFactory sessionFactor;

    @Inject
    Greeter(SessionFactory sessionFactor) {
        this.sessionFactor = sessionFactor;
    }

    public void greet(String phrase) {
        try (Session session = sessionFactor.openSession()) {
            Transaction tx = session.beginTransaction();
            session.save(new GreetingEntity(null, phrase));
            tx.commit();
        }
    }

    public SessionFactory getSessionFactor() {
        return sessionFactor;
    }

}
{% endhighlight %}

{% highlight java linenos=table %}
@Entity
@Table
public class GreetingEntity {

    private Long id;
    private String phrase;

    public GreetingEntity() {
    }

    public GreetingEntity(Long greetingId, String phrase) {
        this.id = greetingId;
        this.phrase = phrase;
    }

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    @Column(length = 128)
    public String getPhrase() {
        return phrase;
    }

    public void setPhrase(String phrase) {
        this.phrase = phrase;
    }
}
{% endhighlight %}

and the following Spring Java Config and which uses In-Memory Derby Database in
the production code:

{% highlight java linenos=table %}
@ComponentScan
@Configuration
public class GreetingConfig {

    @Bean
    DataSource dataSourceProvider() {
        //Derby Embedded Database Data Source
        EmbeddedDataSource dataSource = new EmbeddedDataSource();
        dataSource.setDatabaseName("memory:target/GreetingApplication");
        dataSource.setCreateDatabase("create");

        return dataSource;
    }

}
{% endhighlight %}

The Spring integration test for the `Greeter` service would look:

{% highlight java linenos=table %}
@Module(GreetingConfig.class)
@Need(InMemoryHSQL.class)
@RunWith(SpringIntegrationTest.class)
public class GreetingNeedTest {

    @Cut
    Greeter cut;

    @Real
    SessionFactory sessionFactory;

    @Test
    public void callToGreetShouldSaveAndReturnPhrase() {
        String phrase = "Hello!";

        cut.greet(phrase);

        Session session = sessionFactory.openSession();
        List<GreetingEntity> greetings = session.createCriteria(GreetingEntity.class).list();

        assertThat(greetings).hasSize(1);
        GreetingEntity entity = greetings.stream().findFirst().get();
        assertThat(entity.getId()).isNotNull();
        assertThat(entity.getPhrase()).isEqualTo(phrase);
    }

}
{% endhighlight %}

@Need? Hmmm...

By now you are already familiar with the basics of Spring integration testing
with Testify. If not please refer to the Spring Integration testing section.

One of the first things you will notice in the `GreetingNeedTest` class above is
the `@Need` annotation. This annotation tells Testify that `GreetingNeedTest`
integration test needs a database, an in-memory HSQL database provided by 
`InMemoryHSQL` class. For integration testing and validation of your production
it is often desirable to use an in-memory in lieu of the real production database
to perform isolated testing and reduce the cost of database setup and teardown
time.

The `InMemoryHSQL` class implements `NeedProvider` API contract and provides an
HSQL DataSource to production code that needs a DataSource. Under the hood Testify:

1. loads`InMemoryHSQL` and retrieves the DataSource it provides
1. adds the DataSource to the Spring Application Context as a primary DataSource bean.

Together these steps effectively replace any existing beans that provider
a DataSource within the production code with the DataSource provided by
`InMemoryHSQL`.

An in-memory database need is just one example a need. If your production code
has other needs (i.e. email service)  you can simply create your own test need
implementation by implementing `NeedProvider` contract and Testify will take
care of managing its lifecycle.

---

### Spring System Test with Postgres Database Docker Container Need

---

### Setting Up Docker Locally

#### Install Docker
Before you can test your application with Docker container based needs you have
to install Docker on your machine. To install Docker please follow the
[Docker instalation instructions](https://docs.docker.com/engine/installation/).

#### Configuring Docker
Testify uses Docker Remote API to pull images and manage Docker containers. By
default Docker Remote API is not enabled. To enable it insure that `DOCKER_OPTS`
and `DOCKER_TLS_VERIFY` environmental variable are set to the following:

{% highlight bash linenos=table %}
export DOCKER_OPTS=" -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock"
export DOCKER_TLS_VERIFY=0
{% endhighlight %}


#### Configure Dependencies
For Spring System Testing with Docker container need add the following
dependencies:

{% highlight text linenos=table %}
<dependency>
    <groupId>com.fitbur.testify.junit</groupId>
    <artifactId>spring-system-test</artifactId>
    <version>latest</version>
    <scope>test</scope>
</dependency>

<dependency>
    <groupId>com.fitbur.testify.need</groupId>
    <artifactId>need-docker</artifactId>
    <version>${project.version}</version>
    <scope>test</scope>
</dependency>

<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
    <version>4.2.3.RELEASE</version>
</dependency>

<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <version>4.12</version>
    <scope>test</scope>
</dependency>

<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <version>2.0.31-beta</version>
    <scope>test</scope>
</dependency>
{% endhighlight %}

### Example Spring Integration Test
Given the following Spring MVC Application:

{% highlight java linenos=table %}
public class GreeterApplication extends AbstractAnnotationConfigDispatcherServletInitializer {

    @Override
    protected Class<?>[] getRootConfigClasses() {
        return null;
    }

    @Override
    protected Class<?>[] getServletConfigClasses() {
        return new Class[]{GreeterWebConfig.class};
    }

    @Override
    protected String[] getServletMappings() {
        return new String[]{"/"};
    }

    @Override
    protected String getServletName() {
        return "GreeterApplication";
    }

}
{% endhighlight %}

{% highlight java linenos=table %}
@Configuration
@EnableWebMvc
@ComponentScan
public class GreeterWebConfig {

}

{% endhighlight %}

{% highlight java linenos=table %}
@Entity
@Table
public class GreetingEntity {

    private Long greetingId;
    private String phrase;

    public GreetingEntity() {
    }

    public GreetingEntity(Long greetingId, String phrase) {
        this.greetingId = greetingId;
        this.phrase = phrase;
    }

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    public Long getGreetingId() {
        return greetingId;
    }

    public void setGreetingId(Long greetingId) {
        this.greetingId = greetingId;
    }

    @Column(length = 128)
    public String getPhrase() {
        return phrase;
    }

    public void setPhrase(String phrase) {
        this.phrase = phrase;
    }

}

{% endhighlight %}

{% highlight java linenos=table %}
@RestController
public class GreetingResource {

    private final SessionFactory sessionFactory;

    @Autowired
    GreetingResource(SessionFactory sessionFactory) {
        this.sessionFactory = sessionFactory;
    }

    @RequestMapping(path = "/", method = RequestMethod.GET)
    public String greet(@RequestParam String phrase) {
        try (Session session = sessionFactory.openSession()) {
            Transaction tx = session.beginTransaction();
            session.save(new GreetingEntity(null, phrase));
            tx.commit();
        }
        return phrase;
    }

}

{% endhighlight %}

The configuration used for testing would look like:

{% highlight java linenos=table %}
@Configuration
public class TestDatabaseConfig {

    @Primary
    @Bean
    DataSource dataSourceProvider(NeedInstance<InspectContainerResponse> instance) {
        PGPoolingDataSource source = new PGPoolingDataSource();
        source.setDataSourceName("A Data Source");
        source.setServerName(instance.getHost());
        source.setPortNumber(instance.findFirstPort().get());
        source.setDatabaseName("postgres");
        source.setUser("postgres");
        source.setPassword("mysecretpassword");

        return source;

    }
}
{% endhighlight %}

The Spring System Test for the `GreeterResource` with Docker container need
would look:

{% highlight java linenos=table %}
@RunWith(SpringSystemTest.class)
@App(value = GreeterApplication.class)
@Module(TestDatabaseConfig.class)
@NeedContainer(value = "postgres")
public class GreetingApplicationNeedContainerTest {

    @Real
    WebTarget target;

    @Test
    public void verifyInjections() {
        String phrase = "Hello";
        Response result = target.path("/")
                .queryParam("phrase", phrase)
                .request()
                .get();
        assertThat(result).isNotNull();
        assertThat(result.getStatus()).isEqualTo(OK.getStatusCode());
        assertThat(result.readEntity(String.class)).isEqualTo(phrase);
    }

}
{% endhighlight %}

@NeedContainer? Oh!

You should already be familiar with the basic of Spring System testing
with Testify. If not please refer to the Spring System testing first.

One of the first things you will notice in the `GreetingApplicationNeedContainerTest`
class above are the `@NeedContainer` and `@Module` annotations. The `NeedContainer`
tells Testify that `GreetingApplicationNeedContainerTest`
system test needs a database, a Postgres database provided by "postgres" Docker
image. And the `@Module` annotations provides a bean that creates a primary bean
that connects to the Postgres database running inside the Docker container.

For system testing it is necessary to test your production code in
an environment that very closely resembles your production environment. Docker
containers can help us do. How does it all work? Under the hood Testify:

1. downloads the latest Docker postgres image
1. creates and starts a container based on the image
1. waits for all the ports exposed by the container to be reachable
1. adds the `TestDatabaseConfig` to the spring application context

A Posgres database is just one example of a container based need. The Docker
eco-system is very robust and there are many official and community contributed
images. You can leverage these images to test your application against real
resources you use in your production environment and Testify will take care of
managing the lifecycle of these needs.

